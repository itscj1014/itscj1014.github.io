<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Redis 集群</title>
    <url>/posts/174793d2.html</url>
    <content><![CDATA[<p>然后我们在s1目录创建一个sentinel.conf文件，添加下面的内容：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">port 27001</span><br><span class="line">sentinel announce-ip 192.168.150.101</span><br><span class="line">sentinel monitor mymaster 192.168.150.101 7001 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 5000</span><br><span class="line">sentinel failover-timeout mymaster 60000</span><br><span class="line">dir &quot;/tmp/s1&quot;</span><br></pre></td></tr></table></figure>

<p>解读：</p>
<ul>
<li><code>port 27001</code>：是当前sentinel实例的端口</li>
<li><code>sentinel monitor mymaster 192.168.150.101 7001 2</code>：指定主节点信息<ul>
<li><code>mymaster</code>：主节点名称，自定义，任意写</li>
<li><code>192.168.150.101 7001</code>：主节点的ip和端口</li>
<li><code>2</code>：选举master时的quorum值</li>
</ul>
</li>
</ul>
<span id="more"></span>

<p>然后将s1&#x2F;sentinel.conf文件拷贝到s2、s3两个目录中（在&#x2F;tmp目录执行下列命令）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方式一：逐个拷贝</span></span><br><span class="line"><span class="built_in">cp</span> s1/sentinel.conf s2</span><br><span class="line"><span class="built_in">cp</span> s1/sentinel.conf s3</span><br><span class="line"><span class="comment"># 方式二：管道组合命令，一键拷贝</span></span><br><span class="line"><span class="built_in">echo</span> s2 s3 | xargs -t -n 1 <span class="built_in">cp</span> s1/sentinel.conf</span><br></pre></td></tr></table></figure>



<p>修改s2、s3两个文件夹内的配置文件，将端口分别修改为27002、27003：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sed -i -e <span class="string">&#x27;s/27001/27002/g&#x27;</span> -e <span class="string">&#x27;s/s1/s2/g&#x27;</span> s2/sentinel.conf</span><br><span class="line">sed -i -e <span class="string">&#x27;s/27001/27003/g&#x27;</span> -e <span class="string">&#x27;s/s1/s3/g&#x27;</span> s3/sentinel.conf</span><br></pre></td></tr></table></figure>



<h2 id="3-3-启动"><a href="#3-3-启动" class="headerlink" title="3.3.启动"></a>3.3.启动</h2><p>为了方便查看日志，我们打开3个ssh窗口，分别启动3个redis实例，启动命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第1个</span></span><br><span class="line">redis-sentinel s1/sentinel.conf</span><br><span class="line"><span class="comment"># 第2个</span></span><br><span class="line">redis-sentinel s2/sentinel.conf</span><br><span class="line"><span class="comment"># 第3个</span></span><br><span class="line">redis-sentinel s3/sentinel.conf</span><br></pre></td></tr></table></figure>



<p>启动后：</p>
]]></content>
      <categories>
        <category>Redis</category>
        <category>分类一</category>
        <category>分类二</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>标签一</tag>
        <tag>标签二</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/4a17b156.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<p>使用递归方法来反转链表也很直观。递归的思想是将问题分解成更小的子问题，直到问题足够简单时直接解决，然后逐层返回并合并结果。</p>
<h3 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol>
<li><strong>递归终止条件：</strong> 当链表为空或者只有一个节点时，直接返回该节点。</li>
<li><strong>递归处理：</strong> 假设我们已经反转了 <code>head.next</code> 后面的部分，现在需要把当前节点 <code>head</code> 接到反转后的链表的末尾。</li>
<li><strong>调整指针：</strong> 将 <code>head.next.next</code> 指向 <code>head</code>，然后将 <code>head.next</code> 置为 <code>null</code>。</li>
<li><strong>返回新链表头：</strong> 每一层递归返回新的链表头。</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>以下是详细的 Java 代码实现，并附有注释解释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义链表节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="type">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 递归终止条件：当链表为空或只有一个节点时，返回该节点</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归反转后续节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将当前节点连接到反转后的链表尾部</span></span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回新的链表头</span></span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Solution</span> <span class="variable">solution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建测试用链表：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        head.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">        head.next.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">        head.next.next.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">4</span>);</span><br><span class="line">        head.next.next.next.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反转链表</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">result</span> <span class="operator">=</span> solution.reverseList(head);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出结果链表</span></span><br><span class="line">        <span class="keyword">while</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.print(result.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            result = result.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出应该是：5 4 3 2 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><ol>
<li><p><strong>递归终止条件：</strong></p>
<ul>
<li><code>if (head == null || head.next == null) &#123; return head; &#125;</code><br>当链表为空或者只有一个节点时，直接返回当前节点。</li>
</ul>
</li>
<li><p><strong>递归处理：</strong></p>
<ul>
<li><code>ListNode newHead = reverseList(head.next);</code><br>递归反转从 <code>head.next</code> 开始的子链表，<code>newHead</code> 是反转后的新链表头。</li>
</ul>
</li>
<li><p><strong>调整指针：</strong></p>
<ul>
<li><code>head.next.next = head;</code> 将 <code>head</code> 接到反转后的链表末尾。</li>
<li><code>head.next = null;</code> 将当前节点的 <code>next</code> 指针置为空，避免形成环。</li>
</ul>
</li>
<li><p><strong>返回新链表头：</strong></p>
<ul>
<li><code>return newHead;</code> 返回新的链表头。</li>
</ul>
</li>
</ol>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度：</strong> O(n)。每个节点被访问一次。</li>
<li><strong>空间复杂度：</strong> O(n)。由于递归调用的栈深度为 <code>n</code>，需要 <code>O(n)</code> 的栈空间。</li>
</ul>
<h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p>假设链表为：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</p>
<ol>
<li><p>第一次递归：</p>
<ul>
<li>递归调用 <code>reverseList(2 -&gt; 3 -&gt; 4 -&gt; 5)</code></li>
<li>返回 <code>5 -&gt; 4 -&gt; 3 -&gt; 2</code></li>
</ul>
</li>
<li><p>第二次递归：</p>
<ul>
<li>递归调用 <code>reverseList(3 -&gt; 4 -&gt; 5)</code></li>
<li>返回 <code>5 -&gt; 4 -&gt; 3</code></li>
</ul>
</li>
<li><p>第三次递归：</p>
<ul>
<li>递归调用 <code>reverseList(4 -&gt; 5)</code></li>
<li>返回 <code>5 -&gt; 4</code></li>
</ul>
</li>
<li><p>第四次递归：</p>
<ul>
<li>递归调用 <code>reverseList(5)</code></li>
<li>返回 <code>5</code></li>
</ul>
</li>
<li><p>调整指针：</p>
<ul>
<li>将 <code>4</code> 指向 <code>3</code>，将 <code>3</code> 指向 <code>2</code>，将 <code>2</code> 指向 <code>1</code></li>
</ul>
</li>
</ol>
<p>最后返回反转后的链表头 <code>5</code>。</p>
<p>通过这种递归方法，我们可以有效地反转链表。递归方法利用了函数调用栈，代码简洁且易于理解。</p>
<p><img src="https://gitee.com/van14/image/raw/master/img/202407120424932.png" alt="image-20240712042419865"></p>
]]></content>
      <categories>
        <category>Redis</category>
        <category>锁</category>
        <category>分类一</category>
        <category>分类三</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>标签一</tag>
        <tag>标签二</tag>
        <tag>分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式锁</title>
    <url>/posts/4eb3381c.html</url>
    <content><![CDATA[<h2 id="第一"><a href="#第一" class="headerlink" title="第一"></a>第一</h2><p>为了避免Redis实现的分布式锁超时，Redisson中引入了watch dog的机制，他可以帮助我们在Redisson实例被关闭前，不断的延长锁的有效期。 <strong>自动续租</strong>：当一个Redisson客户端实例获取到一个分布式锁时，如果没有指定锁的超时时间，Watchdog会基于Netty的时间轮启动一个后台任务，定期向Redis发送命令，重新设置锁的过期时间，通常是锁的租约时间的1&#x2F;3。这确保了即使客户端处理时间较长，所持有的锁也不会过期。 <strong>续期时长</strong>：默认情况下，每10s钟做一次续期，续期时长是30s。 <strong>停止续期</strong>：当锁被释放或者客户端实例被关闭时，Watchdog会自动停止对应锁的续租任务。</p>
<p><strong>当我们加锁时，如果指定了<strong><strong>分布式锁</strong></strong>的超时时间，那么是不会开启看门狗逻辑</strong></p>
<p>什么情况下会停止续约：</p>
<p>释放锁的时候，会消费定时任务，停止续约，如果线程被中断了，也会停止续约</p>
<p>但是需要注意的是，Redisson的续期是Netty的时间轮（TimerTask、Timeout、Timer）的，并且操作都是基于JVM的，所以，<strong>当应用宕机、下线或者重启后，续期任务就没有了。这样也能在一定程度上避免机器挂了但是锁一直不释放导致的<strong><strong>死锁</strong></strong>问题</strong></p>
<p>watchdog解锁失败，会不会导致一直续期下去？</p>
<p><strong>不会的，因为在解锁过程中，不管是解锁失败了，还是解锁时抛了异常，都还是会把本地的续期任务停止，避免下次续期。</strong></p>
<p>只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化，得到的结果是这样的：</p>
<span id="more"></span>

<p>缺点：</p>
<ul>
<li>可读性差</li>
<li>内存占用较大</li>
</ul>
<p><img src="https://txyj7dhwr4w.feishu.cn/space/api/box/stream/download/asynccode/?code=ODZiNDUyNGYwZGM2YjJmMzQzMDI5YTMzZWU1MTIxNWVfTmthU0hmZlZNbjFZZXRmMUtKMFByVjBRRDc3M0pJSjVfVG9rZW46RnpXZWIxalVYb2ZqZDF4VDF4YmM3Q0FDblRnXzE3MjA3MzQzOTc6MTcyMDczNzk5N19WNA" alt="img"></p>
<p>所以自定义RedisTemplate的序列化方式：</p>
<h2 id="第二"><a href="#第二" class="headerlink" title="第二"></a>第二</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建RedisTemplate对象</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">// 创建JSON序列化工具</span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">jsonRedisSerializer</span> <span class="operator">=</span> </span><br><span class="line">                               <span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">        <span class="comment">// 设置Key的序列化</span></span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// 设置Value的序列化</span></span><br><span class="line">        template.setValueSerializer(jsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jsonRedisSerializer);</span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSer</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;可爱&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">19</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;12233@qq.com&quot;</span>);</span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;user:100&quot;</span>, user);</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;user:100&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://txyj7dhwr4w.feishu.cn/space/api/box/stream/download/asynccode/?code=YWFhYWUwNDBmZmQzMzJjYTM0ZDIxM2E4NDE3ZjRiOTNfNVRCdm1HVTZraFVqdnBvdFJESGRIM0dISW5aRzBWMGFfVG9rZW46Vm9NV2J5VjY1b0lhc3R4ODhqRmN2SDNabnpsXzE3MjA3MzQzOTc6MTcyMDczNzk5N19WNA" alt="img"></p>
<p>整体可读性有了很大提升，并且能将Java对象自动的序列化为JSON字符串，并且查询时能自动把JSON反序列化为Java对象。不过，其中<strong>记录了<strong><strong>序列化</strong></strong>时对应的class名称，目的是为了查询时实现自动反序列化。这会带来额外的<strong><strong>内存</strong></strong>开销。</strong></p>
<h2 id="第三StringRedisTemplate"><a href="#第三StringRedisTemplate" class="headerlink" title="第三StringRedisTemplate"></a>第三StringRedisTemplate</h2><p>为了节省内存空间，我们可以不使用JSON序列化器来处理value，而是<strong>统一使用String序列化器，要求只能存储String类型的key和value。当需要存储Java对象时，手动完成对象的序列化和反序列化</strong></p>
<p>使用 Jackson 手动序列化和反序列化</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">import com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"></span><br><span class="line">ObjectMapper mapper = new ObjectMapper();</span><br><span class="line">// 序列化</span><br><span class="line">String json = mapper.writeValueAsString(someObject);</span><br><span class="line">// 反序列化</span><br><span class="line">MyObject obj = mapper.readValue(json, MyObject.class);</span><br></pre></td></tr></table></figure>

<p>因为存入和读取时的序列化及反序列化都是我们自己实现的，SpringDataRedis就不会将class信息写入Redis了。</p>
<p><img src="https://txyj7dhwr4w.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjBiOGY3ODE4Y2YwZjdhZWNiODZmNWUyOWM1YjFmNjFfQkI2Q3Q4NnJCS0xveUFzNE5xejZHTWRvZHEzdHVrU2NfVG9rZW46TDhoY2JibGxyb2VYakF4MHBoOGNxZXU5bkRkXzE3MjA3MzQzOTc6MTcyMDczNzk5N19WNA" alt="img"></p>
<p>SpringDataRedis就提供了RedisTemplate的子类：StringRedisTemplate，它的key和value的序列化方式默认就是String方式</p>
<p>省去了我们自定义RedisTemplate的序列化方式的步骤，而是直接使用</p>
<p><img src="https://txyj7dhwr4w.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGVhZjZkMmVlYWNmNDFkY2ExMDRjNTBiZDQ4ODJiODBfWUlVd2FIU2xRZU5mWHZxV2dSU25sdkNrbWc2RXlnWkVfVG9rZW46QmV5TmJxTlZsb0VVY1l4akV2c2NQdXNqbkNlXzE3MjA3MzQzOTc6MTcyMDczNzk5N19WNA" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JSON序列化工具</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;清凉&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">12</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;544545@qq.com&quot;</span>);</span><br><span class="line">    <span class="comment">//手动序列化</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(user);</span><br><span class="line"></span><br><span class="line">    stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:99&quot;</span>, json);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonUser</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user:99&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> mapper.readValue(jsonUser, User.class);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;user1 = &quot;</span> + user1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://txyj7dhwr4w.feishu.cn/space/api/box/stream/download/asynccode/?code=OGFjNzliMjNkZDUxY2JhOWI2NzhjNTY1M2RlMDRiMDBfNE9sSXU5RGpPUVhVU3Fja0lMR3NrUE5rekRhTkZjZnBfVG9rZW46UkZURWJaMzBEb01iWUF4Zm56OGMyOWNMblFlXzE3MjA3MzQzOTc6MTcyMDczNzk5N19WNA" alt="img"></p>
]]></content>
      <categories>
        <category>Redis</category>
        <category>锁</category>
        <category>分类一</category>
        <category>分类二</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>标签一</tag>
        <tag>分布式锁</tag>
        <tag>标签三</tag>
      </tags>
  </entry>
  <entry>
    <title>测试图片</title>
    <url>/posts/8bf59925.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />



<h1 id="测试图片显示"><a href="#测试图片显示" class="headerlink" title="测试图片显示"></a>测试图片显示</h1><p>这是一个测试图片显示的问题。</p>
<img src="https://gitee.com/van14/image/raw/master/img/202407120708678.jpeg"/>





<p><img src="https://gitee.com/van14/image/raw/master/img/202407120706898.jpeg"></p>
<p><img src="https://gitee.com/van14/image/raw/master/img/202407120646802.png" alt="image-20240712064658756"></p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>图片</tag>
      </tags>
  </entry>
</search>
